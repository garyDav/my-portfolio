---
// No hay props por ahora
---

<style>
  #bird-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>

<div id="bird-container"></div>

<script type="module">
  import * as THREE from 'three';
  import Stats from 'three/addons/libs/stats.module.js';
	import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
  import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';

  // Shaders como strings (puedes extraerlos a archivos y hacer fetch si quieres)
  const fragmentShaderPosition = `
    uniform float time;
    uniform float delta;
    uniform sampler2D texturePosition;
    uniform sampler2D textureVelocity;
    varying vec2 vUv;

    void main() {
      vec2 uv = gl_FragCoord.xy / resolution.xy;
      vec4 tmpPos = texture2D( texturePosition, uv );
      vec3 position = tmpPos.xyz;
      vec3 velocity = texture2D( textureVelocity, uv ).xyz;

      float phase = tmpPos.w;

      phase = mod( ( phase + delta +
        length( velocity.xz ) * delta * 3. +
        max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );

      gl_FragColor = vec4( position + velocity * delta * 15. , phase );
    }
  `;

  const fragmentShaderVelocity = `
    uniform float time;
    uniform float testing;
    uniform float delta;
    uniform float separationDistance;
    uniform float alignmentDistance;
    uniform float cohesionDistance;
    uniform float freedomFactor;
    uniform vec3 predator;

    const float width = resolution.x;
    const float height = resolution.y;

    const float PI = 3.141592653589793;
    const float PI_2 = PI * 2.0;

    float zoneRadius = 40.0;
    float zoneRadiusSquared = 1600.0;

    float separationThresh = 0.45;
    float alignmentThresh = 0.65;

    const float UPPER_BOUNDS = BOUNDS;
    const float LOWER_BOUNDS = -UPPER_BOUNDS;

    const float SPEED_LIMIT = 9.0;

    float rand( vec2 co ){
      return fract( sin( dot( co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );
    }

    void main() {
      zoneRadius = separationDistance + alignmentDistance + cohesionDistance;
      separationThresh = separationDistance / zoneRadius;
      alignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;
      zoneRadiusSquared = zoneRadius * zoneRadius;

      vec2 uv = gl_FragCoord.xy / resolution.xy;
      vec3 birdPosition, birdVelocity;

      vec3 selfPosition = texture2D( texturePosition, uv ).xyz;
      vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;

      float dist;
      vec3 dir;
      float distSquared;

      float separationSquared = separationDistance * separationDistance;
      float cohesionSquared = cohesionDistance * cohesionDistance;

      float f;
      float percent;

      vec3 velocity = selfVelocity;

      float limit = SPEED_LIMIT;

      dir = predator * UPPER_BOUNDS - selfPosition;
      dir.z = 0.;
      dist = length( dir );
      distSquared = dist * dist;

      float preyRadius = 150.0;
      float preyRadiusSq = preyRadius * preyRadius;

      if ( dist < preyRadius ) {
        f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;
        velocity += normalize( dir ) * f;
        limit += 5.0;
      }

      vec3 central = vec3( 0., 0., 0. );
      dir = selfPosition - central;
      dist = length( dir );

      dir.y *= 2.5;
      velocity -= normalize( dir ) * delta * 5.;

      for ( float y = 0.0; y < height; y++ ) {
        for ( float x = 0.0; x < width; x++ ) {
          vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;
          birdPosition = texture2D( texturePosition, ref ).xyz;

          dir = birdPosition - selfPosition;
          dist = length( dir );

          if ( dist < 0.0001 ) continue;

          distSquared = dist * dist;

          if ( distSquared > zoneRadiusSquared ) continue;

          percent = distSquared / zoneRadiusSquared;

          if ( percent < separationThresh ) {
            f = ( separationThresh / percent - 1.0 ) * delta;
            velocity -= normalize( dir ) * f;
          } else if ( percent < alignmentThresh ) {
            float threshDelta = alignmentThresh - separationThresh;
            float adjustedPercent = ( percent - separationThresh ) / threshDelta;

            birdVelocity = texture2D( textureVelocity, ref ).xyz;

            f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;
            velocity += normalize( birdVelocity ) * f;
          } else {
            float threshDelta = 1.0 - alignmentThresh;
            float adjustedPercent = ( percent - alignmentThresh ) / threshDelta;

            f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;

            velocity += normalize( dir ) * f;
          }
        }
      }

      if ( length( velocity ) > limit ) {
        velocity = normalize( velocity ) * limit;
      }

      gl_FragColor = vec4( velocity, 1.0 );
    }
  `;

  const birdVS = `
    attribute vec2 reference;
    attribute float birdVertex;
    attribute vec3 birdColor;

    uniform sampler2D texturePosition;
    uniform sampler2D textureVelocity;

    varying vec4 vColor;
    varying float z;

    uniform float time;

    void main() {
      vec4 tmpPos = texture2D( texturePosition, reference );
      vec3 pos = tmpPos.xyz;
      vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);

      vec3 newPosition = position;

      if ( birdVertex == 4.0 || birdVertex == 7.0 ) {
        newPosition.y = sin( tmpPos.w ) * 5.;
      }

      newPosition = mat3( modelMatrix ) * newPosition;

      velocity.z *= -1.;
      float xz = length( velocity.xz );
      float xyz = 1.;
      float x = sqrt( 1. - velocity.y * velocity.y );

      float cosry = velocity.x / xz;
      float sinry = velocity.z / xz;

      float cosrz = x / xyz;
      float sinrz = velocity.y / xyz;

      mat3 maty =  mat3(
        cosry, 0, -sinry,
        0    , 1, 0     ,
        sinry, 0, cosry
      );

      mat3 matz =  mat3(
        cosrz , sinrz, 0,
        -sinrz, cosrz, 0,
        0     , 0    , 1
      );

      newPosition =  maty * matz * newPosition;
      newPosition += pos;

      z = newPosition.z;

      vColor = vec4( birdColor, 1.0 );
      gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );
    }
  `;

  const birdFS = `
    varying vec4 vColor;
    varying float z;

    uniform vec3 color;

    void main() {
      float z2 = 0.2 + ( 1000. - z ) / 1000. * vColor.x;
      gl_FragColor = vec4( z2, z2, z2, 1. );
    }
  `;

  // Constantes
  const WIDTH = 32;
  const BIRDS = WIDTH * WIDTH;
  const BOUNDS = 800;
  const BOUNDS_HALF = BOUNDS / 2;

  let container = document.getElementById('bird-container');
  let camera, scene, renderer;
  let gpuCompute;
  let velocityVariable, positionVariable;
  let positionUniforms, velocityUniforms, birdUniforms;
  let birdMesh;
  let mouseX = 10000, mouseY = 10000;
  let last = performance.now();

  // BirdGeometry class (simplificado)
  class BirdGeometry extends THREE.BufferGeometry {
    constructor() {
      super();

      const trianglesPerBird = 3;
      const triangles = BIRDS * trianglesPerBird;
      const points = triangles * 3;

      const vertices = new THREE.BufferAttribute(new Float32Array(points * 3), 3);
      const birdColors = new THREE.BufferAttribute(new Float32Array(points * 3), 3);
      const references = new THREE.BufferAttribute(new Float32Array(points * 2), 2);
      const birdVertex = new THREE.BufferAttribute(new Float32Array(points), 1);

      this.setAttribute('position', vertices);
      this.setAttribute('birdColor', birdColors);
      this.setAttribute('reference', references);
      this.setAttribute('birdVertex', birdVertex);

      let v = 0;
      function verts_push() {
        for (let i = 0; i < arguments.length; i++) {
          vertices.array[v++] = arguments[i];
        }
      }

      const wingsSpan = 20;

      for (let f = 0; f < BIRDS; f++) {
        // Body
        verts_push(
          0, -0, -20,
          0, 4, -20,
          0, 0, 30
        );

        // Wings
        verts_push(
          0, 0, -15,
          -wingsSpan, 0, 0,
          0, 0, 15
        );

        verts_push(
          0, 0, 15,
          wingsSpan, 0, 0,
          0, 0, -15
        );
      }

      for (let v = 0; v < triangles * 3; v++) {
        const triangleIndex = Math.floor(v / 3);
        const birdIndex = Math.floor(triangleIndex / trianglesPerBird);
        const x = (birdIndex % WIDTH) / WIDTH;
        const y = Math.floor(birdIndex / WIDTH) / WIDTH;

        const c = new THREE.Color(
          0x666666 +
          Math.floor(v / 9) / BIRDS * 0x666666
        );

        birdColors.array[v * 3 + 0] = c.r;
        birdColors.array[v * 3 + 1] = c.g;
        birdColors.array[v * 3 + 2] = c.b;

        references.array[v * 2] = x;
        references.array[v * 2 + 1] = y;

        birdVertex.array[v] = v % 9;
      }

      this.scale(0.2, 0.2, 0.2);
    }
  }

  function fillPositionTexture(texture) {
    const theArray = texture.image.data;
    for (let k = 0, kl = theArray.length; k < kl; k += 4) {
      theArray[k + 0] = Math.random() * BOUNDS - BOUNDS_HALF;
      theArray[k + 1] = Math.random() * BOUNDS - BOUNDS_HALF;
      theArray[k + 2] = Math.random() * BOUNDS - BOUNDS_HALF;
      theArray[k + 3] = 1;
    }
  }

  function fillVelocityTexture(texture) {
    const theArray = texture.image.data;
    for (let k = 0, kl = theArray.length; k < kl; k += 4) {
      theArray[k + 0] = (Math.random() - 0.5) * 10;
      theArray[k + 1] = (Math.random() - 0.5) * 10;
      theArray[k + 2] = (Math.random() - 0.5) * 10;
      theArray[k + 3] = 1;
    }
  }

  function initComputeRenderer() {
    gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);

    const dtPosition = gpuCompute.createTexture();
    const dtVelocity = gpuCompute.createTexture();

    fillPositionTexture(dtPosition);
    fillVelocityTexture(dtVelocity);

    velocityVariable = gpuCompute.addVariable('textureVelocity', fragmentShaderVelocity.replace(/BOUNDS/g, BOUNDS.toFixed(2)), dtVelocity);
    positionVariable = gpuCompute.addVariable('texturePosition', fragmentShaderPosition, dtPosition);

    gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);
    gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);

    positionUniforms = positionVariable.material.uniforms;
    velocityUniforms = velocityVariable.material.uniforms;

    positionUniforms['time'] = { value: 0.0 };
    positionUniforms['delta'] = { value: 0.0 };
    velocityUniforms['time'] = { value: 1.0 };
    velocityUniforms['delta'] = { value: 0.0 };
    velocityUniforms['testing'] = { value: 1.0 };
    velocityUniforms['separationDistance'] = { value: 20.0 };
    velocityUniforms['alignmentDistance'] = { value: 20.0 };
    velocityUniforms['cohesionDistance'] = { value: 20.0 };
    velocityUniforms['freedomFactor'] = { value: 0.75 };
    velocityUniforms['predator'] = { value: new THREE.Vector3() };

    velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed(2);

    velocityVariable.wrapS = THREE.RepeatWrapping;
    velocityVariable.wrapT = THREE.RepeatWrapping;
    positionVariable.wrapS = THREE.RepeatWrapping;
    positionVariable.wrapT = THREE.RepeatWrapping;

    const error = gpuCompute.init();
    if (error !== null) {
      console.error(error);
    }
  }

  function initBirds() {
    const geometry = new BirdGeometry();

    birdUniforms = {
      color: { value: new THREE.Color(0x000000) }, // negro para silueta
      texturePosition: { value: null },
      textureVelocity: { value: null },
      time: { value: 1.0 },
      delta: { value: 0.0 }
    };

    const material = new THREE.ShaderMaterial({
      uniforms: birdUniforms,
      vertexShader: birdVS,
      fragmentShader: birdFS,
      side: THREE.DoubleSide
    });

    birdMesh = new THREE.Mesh(geometry, material);
    birdMesh.rotation.y = Math.PI / 2;
    birdMesh.matrixAutoUpdate = false;
    birdMesh.updateMatrix();

    scene.add(birdMesh);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onPointerMove(event) {
    if (event.isPrimary === false) return;

    mouseX = event.clientX - window.innerWidth / 2;
    mouseY = event.clientY - window.innerHeight / 2;
  }

  function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    let delta = (now - last) / 1000;
    if (delta > 1) delta = 1;
    last = now;

    positionUniforms['time'].value = now;
    positionUniforms['delta'].value = delta;
    velocityUniforms['time'].value = now;
    velocityUniforms['delta'].value = delta;
    birdUniforms['time'].value = now;
    birdUniforms['delta'].value = delta;

    velocityUniforms['predator'].value.set(0.5 * mouseX / (window.innerWidth / 2), -0.5 * mouseY / (window.innerHeight / 2), 0);

    mouseX = 10000;
    mouseY = 10000;

    gpuCompute.compute();

    birdUniforms['texturePosition'].value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
    birdUniforms['textureVelocity'].value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;

    renderer.render(scene, camera);
  }

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    scene.fog = new THREE.Fog(0xffffff, 100, 1000);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
    camera.position.z = 350;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    initComputeRenderer();
    initBirds();

    window.addEventListener('resize', onWindowResize);
    container.addEventListener('pointermove', onPointerMove);

    animate();
  }

  init();
</script>
